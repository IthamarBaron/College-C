#pragma once
#pragma warning(disable : 4996)
#include <stdio.h>
#include <stdlib.h>
#include <string.h> 

#define ROWS 10
#define COLS 10
typedef enum { FALSE = 0, TRUE = 1 } Boolean;
typedef int TYPE_ITEM;
typedef struct sparesMat

{
	int row, col;
	TYPE_ITEM info;
	struct sparesMat* nextRow;
	struct sparesMat* nextCol;

}sparesMatNode, * sMatPtr;

// Function to initialize the sparse matrix
sMatPtr Init(int row, int col, TYPE_ITEM x)
{
	sMatPtr mat = (sMatPtr)malloc(sizeof(sparesMatNode));
	if (mat == NULL)
	{
		printf("Allocation failed\n");
		return NULL;
	}
	mat->col = col;
	mat->row = row;
	mat->info = x;
	mat->nextRow = mat;
	mat->nextCol = mat;
	return mat;
}

// Function to check if the matrix is empty
Boolean IsEmpty(sparesMatNode* mat)
{
	return mat->nextCol == mat || mat->nextRow == mat ? TRUE : FALSE;
}

void printRowsAndColsCount(sparesMatNode* mat) {
	int rowCount = 0;
	int colCount = 0;
	sMatPtr headCol = mat;
	sMatPtr headRow = mat;
	while (headCol->nextCol != mat)
	{
		colCount++;
		headCol = headCol->nextCol;
	}
	while (headRow->nextRow != mat)
	{
		rowCount++;
		headRow = headRow->nextRow;
	}


	printf("Number of rows: %d\n", rowCount);
	printf("Number of columns: %d\n", colCount);
}

// Function to insert a value into the matrix at a given position
void InsertToMatrix(sparesMatNode* mat, int row, int col, TYPE_ITEM x)
{
	row++; col++;
	//check if a row exists
	sMatPtr rowHead = mat;
	int rowCounter = 0;
	while (rowHead->nextRow != mat)
	{
		rowCounter++;
		rowHead = rowHead->nextRow;
	}
	if (rowCounter < row)//we need new rows
	{
		for (int i = rowCounter + 1; i < row + 1; i++)
		{
			sMatPtr newNode = Init(i, 0, -1);
			newNode->nextRow = rowHead->nextRow;
			rowHead->nextRow = newNode;
			rowHead = rowHead->nextRow;
		}
	}
	sMatPtr colHead = mat;
	int ColCounter = 0;
	while (colHead->nextCol != mat)
	{
		ColCounter++;
		colHead = colHead->nextCol;
	}
	if (ColCounter < col)
	{
		for (int i = ColCounter + 1; i < col + 1; i++)
		{
			sMatPtr newNode = Init(0, i, -1);
			newNode->nextCol = colHead->nextCol;
			colHead->nextCol = newNode;
			colHead = colHead->nextCol;
		}
	}

	//find place and place item there
	//find the correct col
	sMatPtr insertCol = mat;
	while (insertCol->col != col)
	{
		insertCol = insertCol->nextCol;
	}

	//find the correct row
	sMatPtr insertRow = mat;
	while (insertRow->row != row)
	{
		insertRow = insertRow->nextRow;
	}

	sMatPtr insertedNode = Init(row, col, x);
	sMatPtr startCol = insertCol;
	if (startCol->nextRow != startCol)
	{
		while (insertCol->nextRow == startCol && insertCol->nextRow->row != row);
		{
			insertCol = insertCol->nextRow;
		}
	}
	sMatPtr startRow = insertRow;
	if (startRow->nextCol != startRow)
	{
		while (insertRow->nextCol->row != row && insertRow->nextCol == startRow)
		{
			insertRow = insertRow->nextCol;
		}
	}

	sMatPtr nextAfterCol = insertCol->nextRow->nextRow;
	insertCol->nextRow = insertedNode;
	insertedNode->nextRow = nextAfterCol;

	sMatPtr nextAfterRow = insertRow->nextCol->nextCol;
	insertRow->nextCol = insertedNode;
	insertedNode->nextCol = nextAfterRow;

}

void InsertAfter(sMatPtr rowBefore, sMatPtr colBefore, TYPE_ITEM X)
{
	sMatPtr newNode = Init(rowBefore->row, colBefore->col, X);

	sMatPtr nextAfterRows = rowBefore->nextCol;
	if (nextAfterRows->col != 0)
		nextAfterRows = nextAfterRows->nextCol;

	rowBefore->nextCol = newNode;
	newNode->nextCol = nextAfterRows;

	sMatPtr nextAfterCols = colBefore->nextRow;
	if (nextAfterCols->row != 0)
		nextAfterCols = nextAfterCols->nextCol;

	colBefore->nextRow = newNode;
	newNode->nextRow = nextAfterCols;

}

TYPE_ITEM DeleteAfter(sMatPtr rowBefore, sMatPtr colBefore)
{
	if (rowBefore != NULL && colBefore != NULL)
	{
		rowBefore->nextCol = rowBefore->nextCol->nextCol;
		sMatPtr* toRemove = colBefore->nextRow;
		colBefore->nextRow = colBefore->nextRow->nextRow;
		TYPE_ITEM value = (*toRemove)->info;
		free(*toRemove);
		return value;
	}
	return FALSE;//0 - values in spares matrix will never be 0 
}


sMatPtr FindAbove(sMatPtr mat, int row, int col)
{
	if (IsEmpty(mat))
		return NULL;
	sMatPtr headRows = mat;
	for (size_t i = 0; i < col; i++)
		headRows->nextCol = headRows->nextCol;
	sMatPtr headColl = headRows;
	while (headRows->nextRow != headRows)
	{
		//FINISH HOME
	}


}

void printSparesMatrix(sparesMatNode* mat) {
	sparesMatNode* row = mat->nextRow;

	// Traverse through each row until we get back to the head
	while (row != mat) {
		sparesMatNode* col = row->nextCol;

		// Traverse through each column until we get back to the row head
		while (col != row) {
			printf("Value at (%d, %d): %d\n", col->row - 1, col->col - 1, col->info);
			col = col->nextCol;
		}

		row = row->nextRow;
	}
}

int main()
{
	sparesMatNode* matrix = Init(0, 0, -1);
	if (IsEmpty(matrix)) {
		printf("Matrix is empty.\n");
	}



	InsertToMatrix(matrix, 0, 1, 1);
	InsertToMatrix(matrix, 1, 0, 2);
	printf("first param mat at[%d][%d]\nsecond param mat at[%d][%d]\n",
		matrix->nextRow->nextRow->nextCol->row, matrix->nextRow->nextRow->nextCol->col, matrix->nextCol->nextCol->nextRow->row, matrix->nextCol->nextCol->nextRow->col);
	InsertAfter(matrix->nextRow->nextRow->nextCol, matrix->nextCol->nextCol->nextRow, 3);




	printSparesMatrix(matrix);

	return 0;
}
